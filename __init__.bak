#!/usr/bin/env python3
#
#########################################################################
#  Copyright 2020 Ronny Schulz
#########################################################################
#
#  This file is part of SmartHomeNG.
#
#  SmartHomeNG is free software: you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.
#
#  SmartHomeNG is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with SmartHomeNG. If not, see <http://www.gnu.org/licenses/>.
#
#########################################################################

from datetime import datetime
import time
import threading
import logging
from lib.model.smartplugin import SmartPlugin

# pymodbus library from https://code.google.com/p/pymodbus/
from pymodbus.client.sync import ModbusTcpClient
from pymodbus.constants import Endian
from pymodbus.payload import BinaryPayloadDecoder
from pymodbus.payload import BinaryPayloadBuilder

class PluggitV2(SmartPlugin):

    PLUGIN_VERSION="2.0.0b1"

    _myTempReadDict = {}
    _myTempWriteDict = {}
    
    DICT_READ_ADDRESS = 0
    DICT_WRITE_ADDRESS = 1
    DICT_ADDRESS_QUANTITY = 2
    DICT_VALUE_TYPE = 3
    DICT_ROUND_VALUE = 4
    DICT_MIN_VALUE = 5
    DICT_MAX_VALUE = 6
    
    #============================================================================#
    # define variables for most important modbus registers of KWL "Pluggit AP310"
    #
    # Important: In the PDU Registers are addressed starting at zero.
    # Therefore registers numbered 1-16 are addressed as 0-15.
    # that means e.g. holding register "40169" is "40168" and so on
    #============================================================================#

    # 1: Bezeichnung des Registers (key)
    # 2: Lese-Adresse des Registers (0)
    # 3: Schreib-Adresse des Registers (1)
    # 4: LÃ¤nge des Registers (2)
    # 5: Typ des Wertes (3)
    # 6: minimaler Wert (4)
    # 7: maximaler Wert (5)
    _modbusRegisterDic = {
        'prmSystemID': [2, -1, 2, 'uint', -1],
        'prmSystemSerialNum': [4, -1, 4, 'uint64', -1],
        'prmSystemName': [8, 8, 16, 'str', -1],
        'prmFWVersion': [24, -1, 1, 'uint', -1],
        'prmDHCPEN': [26, -1, 2, 'bool', -1],
        'prmCurrentIPAddress': [28, -1, 2, 'ip', -1],
        'prmCurrentIPMask': [32, -1, 2, 'ip', -1],
        'prmCurrentIPGateway': [36, -1, 2, 'ip', -1],
        'prmMACAddr': [40, -1, 4, 'mac', -1],
        'prmHALLeft': [84, -1, 2, 'bool', -1],
        'prmHALRight': [86, -1, 2, 'bool', -1],
        'prmHALTaho1': [100, -1, 2, 'float', 0],
        'prmHALTaho2': [102, -1, 2, 'float', 0],
        'prmDateTime': [108, 110, 2, 'datetime', -1],
        'prmRamIdxT1': [132, -1, 2, 'float', 2],
        'prmRamIdxT2': [134, -1, 2, 'float', 2],
        'prmRamIdxT3': [136, -1, 2, 'float', 2],
        'prmRamIdxT4': [138, -1, 2, 'float', 2],
        'prmRamIdxT5': [140, -1, 2, 'float', 2],
        'prmPreheaterDutyCycle': [160, -1, 2, 'uint', -1],
        'prmRamIdxUnitMode': [168, 168, 2, 'uint', -1],
        'prmRamIdxHac1FirmwareVersion': [192, -1, 2, 'uint', -1],
        'prmRamIdxRh3Corrected': [196, -1, 2, 'uint', -1],
        'prmRamIdxBypassActualState': [198, -1, 2, 'special', -1],
        'prmRamIdxHac1Components': [244, -1, 2, 'special', -1],
        'prmRamIdxBypassManualTimeout': [264, -1, 2, 'uint', -1],
        'prmRomIdxSpeedLevel': [324, 324, 2, 'uint', -1],
        'prmRomIdxNightModeStartHour': [332, 332, 2, 'uint', -1],
        'prmRomIdxNightModeStartMin': [334, 334, 2, 'uint', -1],
        'prmRomIdxNightModeEndHour': [336, 336, 2, 'uint', -1],
        'prmRomIdxNightModeEndMin': [338, 338, 2, 'uint', -1],
        'prmRomIdxRhSetPoint': [340, -1, 2, 'uint', -1],
        'prmRomIdxAfterHeaterT2SetPoint': [344, 344, 2, 'uint', -1],
        'prmRomIdxAfterHeaterT3SetPoint': [346, 346, 2, 'uint', -1],
        'prmRomIdxAfterHeaterT5SetPoint': [348, 348, 2, 'uint', -1],
        'prmVOC': [430, -1, 2, 'uint', -1],
        'prmBypassTmin': [444, -1, 2, 'float', -1],
        'prmBypassTmax': [446, -1, 2, 'float', -1],
        'prmNumOfWeekProgram': [466, 467, 2, 'uint', -1],
        'prmCurrentBLState': [472, -1, 2, 'uint', -1],
        'prmSetAlarmNum': [514, 514, 2, 'uint', -1],
        'prmLastActiveAlarm': [516, 516, 2, 'uint', -1],
        'prmRefValEx': [518, -1, 2, 'uint', -1],
        'prmRefValSupl': [520, -1, 2, 'uint', -1],
        'prmFireplacePreset': [540, -1, 2, 'bool', -1],
        'prmFilterRemainingTime': [554, -1, 2, 'uint', -1],
        'prmFilterDefaultTime': [556, 556, 2, 'uint', -1],
        'prmFilterReset': [558, 558, 2, 'bool', -1],
        'prmPPM1Unit': [562, 562, 2, 'uint', -1],
        'prmPPM2Unit': [564, 564, 2, 'uint', -1],
        'prmPPM3Unit': [566, 566, 2, 'uint', -1],
        'prmPPM1External': [568, 568, 2, 'uint', -1],
        'prmPPM2External': [570, 570, 2, 'uint', -1],
        'prmPPM3External': [572, 572, 2, 'uint', -1],
        'prmHACCO2Val': [574, -1, 2, 'uint', -1],
        'prmSystemIDComponents': [611, -1, 2, 'uint', -1],
        'prmWorkTime': [624, -1, 2, 'uint', -1],
        'PrmWeekMon1': [626, 626, 2, 'special', -1],
        'PrmWeekMon2': [628, 628, 2, 'special', -1],
        'PrmWeekMon3': [630, 630, 2, 'special', -1],
        'PrmWeekTue1': [632, 632, 2, 'special', -1],
        'PrmWeekTue2': [634, 634, 2, 'special', -1],
        'PrmWeekTue3': [636, 636, 2, 'special', -1],
        'PrmWeekWed1': [638, 638, 2, 'special', -1],
        'PrmWeekWed2': [640, 640, 2, 'special', -1],
        'PrmWeekWed3': [642, 642, 2, 'special', -1],
        'PrmWeekThu1': [644, 644, 2, 'special', -1],
        'PrmWeekThu2': [646, 646, 2, 'special', -1],
        'PrmWeekThu3': [648, 648, 2, 'special', -1],
        'PrmWeekFri1': [650, 650, 2, 'special', -1],
        'PrmWeekFri2': [652, 652, 2, 'special', -1],
        'PrmWeekFri3': [654, 655, 2, 'special', -1],
        'PrmWeekSat1': [656, 656, 2, 'special', -1],
        'PrmWeekSat2': [658, 658, 2, 'special', -1],
        'PrmWeekSat3': [660, 660, 2, 'special', -1],
        'PrmWeekSun1': [662, 662, 2, 'special', -1],
        'PrmWeekSun3': [664, 665, 2, 'special', -1],
        'PrmWeekSun3': [666, 666, 2, 'special', -1],
        'prmStartExploitationDateStamp': [668, -1, 2, 'datetime', -1]
    }

    # Initialize connection
    def __init__(self, sh, *args, **kwargs):
        self.logger = logging.getLogger(__name__)
        self._host = self.get_parameter_value('host')
        self._port = int(self.get_parameter_value('port'))
        self._cycle = int(self.get_parameter_value('cycle'))
        self._lock = threading.Lock()
        self._is_connected = False
        self._items = {}
        self.connect()

    def connect(self):
        start_time = time.time()
        if self._is_connected:
            return True
        self._lock.acquire()
        try:
            self.logger.info("Pluggit: connecting to {0}:{1}".format(self._host, self._port))
            self._Pluggit = ModbusTcpClient(self._host, self._port)
        except Exception as e:
            self.logger.error("Pluggit: could not connect to {0}:{1}: {2}".format(self._host, self._port, e))
            return
        finally:
            self._lock.release()
        self.logger.info("Pluggit: connected to {0}:{1}".format(self._host, self._port))
        self._is_connected = True
        end_time = time.time()
        self.logger.debug("Pluggit: connection took {0} seconds".format(end_time - start_time))

    def disconnect(self):
        start_time = time.time()
        if self._is_connected:
            try:
                self._Pluggit.close()
            except:
                pass
        self._is_connected = False
        end_time = time.time()
        self.logger.debug("Pluggit: disconnect took {0} seconds".format(end_time - start_time))

    def run(self):
        self.scheduler_add(__name__, self._refresh, cycle=self._cycle)
        self.alive = True

    def stop(self):
        self.alive = False

    def parse_item(self, item):
        # check for smarthome.py attribute 'pluggit_read' in pluggit.conf
        if self.has_iattr(item.conf, 'pluggit_read'):
            self.logger.debug("Pluggit: parse read item: {0}".format(item))
            pluggit_key = self.get_iattr_value(item.conf, 'pluggit_read')
            if pluggit_key in self._modbusRegisterDic:
                self._myTempReadDict[pluggit_key] = item
                self.logger.debug("Pluggit: Inhalt des dicts _myTempReadDict nach Zuweisung zu item: '{0}'".format(self._myTempReadDict))
            else:
                self.logger.warn("Pluggit: invalid key {0} configured".format(pluggit_key))                
        # check for smarthome.py attribute 'pluggit_write' in pluggit.conf
        if self.has_iattr(item.conf, 'pluggit_write'):
            self.logger.debug("Pluggit: parse write item: {0}".format(item))
            pluggit_sendKey = self.get_iattr_value(item.conf, 'pluggit_write')
            if pluggit_sendKey is None:
                return None
            else:
                self._myTempWriteDict[pluggit_sendKey] = item
                self.logger.debug("Pluggit: Inhalt des dicts _myTempWriteDict nach Zuweisung zu write item: '{0}'".format(self._myTempWriteDict))
        else:
            return None

    def _refresh(self):
        start_time = time.time()
        try:
            myCounter = 1
            for pluggit_key in self._myTempReadDict:
                self.logger.debug("Pluggit: ---------------------------------> Wir sind in der Refresh Schleife")
                values = self._modbusRegisterDic[pluggit_key]
                self.logger.debug("Pluggit: Refresh Schleife: Inhalt von values ist {0}".format(values))
                item = self._myTempReadDict[pluggit_key]
                conv = None
                if self.has_iattr(item.conf, 'pluggit_convert'):
                    conv = self.get_iattr_value(item.conf, 'pluggit_convert')
                    self.logger.debug("Pluggit: CONVERTER: {0}".format(conv))
                #self.logger.warn("Pluggit: Refresh Schleife: Inhalt von item ist {0}".format(item))

                #=======================================================#
                # read values from pluggit via modbus client registers
                #=======================================================#

                self.logger.debug("Pluggit: ------------------------------------------> Wir sind vor dem Auslesen der Werte")
                registerValue = None
                registerValue = self._Pluggit.read_holding_registers(values[self.DICT_READ_ADDRESS], values[self.DICT_ADDRESS_QUANTITY])
                vdecoder = BinaryPayloadDecoder.fromRegisters(registerValue.registers, byteorder=Endian.Big, wordorder=Endian.Little)
                #registerValue = self._Pluggit.read_holding_registers(values, read_qty = 1).getRegister(0)
                self.logger.debug("Pluggit: Read parameter '{0}' with register '{1}': Value is '{2}'".format(pluggit_key, values, registerValue))

                result = None

                if values[self.DICT_READ_ADDRESS] != -1:
                    if values[self.DICT_VALUE_TYPE] == 'uint':
                        vresult = vdecoder.decode_16bit_uint()
                        result = vresult

                    if values[self.DICT_VALUE_TYPE] == 'uint64':
                        vresult = vdecoder.decode_64bit_uint()
                        result = vresult

                    if values[self.DICT_VALUE_TYPE] == 'datetime':
                        vresult = vdecoder.decode_16bit_uint()
                        result = vresult

                    if values[self.DICT_VALUE_TYPE] == 'bool':
                        vresult = vdecoder.decode_bits()
                        if vresult == 0:
                            result = False
                        else:
                            result = True

                    if values[self.DICT_VALUE_TYPE] == 'float':
                        vresult = vdecoder.decode_32bit_float()
                        if values[self.DICT_ROUND_VALUE] != -1:
                            vresult = round(vresult, values[self.DICT_ROUND_VALUE])
                        result = vresult

                    if values[self.DICT_VALUE_TYPE] == 'str':
                        vresult = str(vdecoder.decode_string(8))
                        result = vresult

                    if values[self.DICT_VALUE_TYPE] == 'ip':
                        ipadress = '{}.{}.{}.{}'.format(registerValue.registers[1] >> 8, registerValue.registers[1] & 255, registerValue.registers[0] >> 8, registerValue.registers[0] & 255)
                        result = ipadress

                    if values[self.DICT_VALUE_TYPE] == 'mac':
                        macadress = '{:02x}:{:02x}:{:02x}:{:02x}:{:02x}:{:02x}'.format(registerValue.registers[0] >> 8, registerValue.registers[0] & 255, registerValue.registers[3] >> 8, registerValue.registers[3] & 255, registerValue.registers[2] >> 8, registerValue.registers[2] & 255)
                        result = macadress

                    # check for converts
                    if conv == 'ToDateTime':
                        #cresult = datetime.utcfromtimestamp(vresult)
                        cresult = datetime.fromtimestamp(vresult)
                        result = cresult

                    if result is not None:
                        item(result, 'Pluggit')

                self.logger.debug("Pluggit: ------------------------------------------> Ende der Schleife vor sleep, Durchlauf Nr. {0}".format(myCounter))
                time.sleep(0.1)
                myCounter += 1

        except Exception as e:
            self.logger.error("Pluggit: something went wrong in the refresh function: {0}".format(e))
            return

        end_time = time.time()
        cycletime = end_time - start_time
        self.logger.debug("Pluggit: cycle took {0} seconds".format(cycletime))